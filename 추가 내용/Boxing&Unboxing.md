## 박싱된 값 타입과 박싱되지 않은 값 타입⭐⭐⭐
### 박싱
- 값 타입을 Object 타입으로 바꾸거나 인터페이스 타입으로 바꾸는 것을 말함
- ```C#
    int i = 100;
    object o = i;
    // This is boxinig
  ```
- 위의 코드 내용처럼 object에 값 타입을 넣어줄 때를 박싱이라고 하는데 힙 영역에 100이라는 값을 가진 변수를 object가 참조하게 함
- 100을 담은 i박스를 힙 영역에 만들어주고 object가 이것을 참조한 것이므로 박싱이라는 말이 말이 됨.
- 참고한 사이트: `https://hongjinhyeon.tistory.com/90`
- 값 타입은 참조 타입보다 가벼움 <- 관리되는 힙에 객체로 할당되지 않기 때문!
- 가비지 컬렉터가 관리하지 않으며 포인터로 지칭되지 않음
- 그러나 값 타입에 대한 참조를 얻어야만 하는 일이 자주 있음
  - 값 타입 변수 내용을 ArrayList같은 곳에 담아 넣을 때 그러함.
  - 값 타입이 참조타입으로 변환되는 과정이 필요함 => '박싱'이라고 함
- 박싱이 일어나면서 진행되는 일들
  1. 관리되는 힙에 메모리가 할당됨
  2. 값 타입의 필드들은 새로 할당된 힙 메모리에 복사됨
  3. 객체의 메모리 주소가 반환됨

### 언박싱
  - object 타입을 값 타입으로 바꾸거나 인터페이스 타입에서 값 타입으로 바꾸는 것을 언박싱이라고 함
  - ```C#
      int i = 100;
      object o = i;
      // This is boxinig
      int j = (int)o;
      // This is unboxing
    ```
  - 박스를 풀어본다? 는 뜻인데 박스 처리되어있는 o의 값을 풀어서 스택영역의 j에 정수값을 넣어주는 것이니 맞음.
  - 언박싱 시 같은 타입인지 타입 확인을 잘 해줘야 에러가 나지 않음
  - 박싱 작업에 비해 훨씬 적은 연산 수행
  - 박싱된 객체 안에 들어있는 원래의 값의 포인터를 얻어오는 것
  - 박싱된 인스턴스 안에 언박싱된 부분의 포인터를 가져오는 효과가 있음
  - 메모리 복사를 수반하지 않음
  - 언박싱 연산이 이루어진 다음 필드를 복사하는 작업이 이루어짐

- 박싱 & 언박싱/복사 작업 -> 응용프로그램의 속도와 메모리 소비 면에서 모두 성능 저하 일어남
- => 컴파일러가 이런 작업에 적게 의존하도록 코드 작성하는 것이 필요함

- 내부적으로 박싱된 값 타입 인스턴스를 언박싱하는 과정
- 1. 어떤 변수에 박싱된 값 타입의 인스턴스의 참조가 null로 설정되어 있으면 NullReferenceException이 발생함
- 2. 참조가 원하는 타입에 대한 박싱 객체를 가리키지 않는 경우, InvalidCastException 예외가 발생함

```C#
public static void Main()
{
    Int32 x = 5;
    Object o = x;               //x를 박싱하여 o에 객체 참조를 대입
    Int16 y = (Int16) o;        //InvalidCastException 예외가 발생
}
```
- 기대한 것과는 다른 동작...
- 논리적으로 문제가 없으나... 객체를 언박싱할 때, 이 경우에는 Int32 타입으로 정확하게 지정해줘야 함

- [수정 코드]
```C#
public static void Main()
{
    Int32 x = 5;
    Object o = x;                 //x를 박싱하여 o에 객체 참조를 대입
    Int16 y = (Int16)(Int32) o;   //우선 언박싱하고 정확한 타입으로 다시 캐스팅
}
```

- [언박싱과 복사가 같이 이루어지는 경우]
```C#
public static void Main()
{
    Point p;
    p.x = p.y = 1;
    Object o = p;         // p를 박싱하여 o에 객체 참조를 대입한다
    p = (Point)  o;       // o를 언박싱하고 박싱된 인스턴스 내의 모든 필드를 스택 변수상으로 복사해 넣음
}
```
- 마지막 줄에서 C# 컴파일러가 박싱된 인스턴스에 대한 주소를 갖고 있는 o를 언박싱 -> 필드의 시작 주소 얻어옴
- 필드의 모든 데이터를 스택 변수 p의 메모리 공간으로 복사하는 IL 코드를 자동으로 생성함

```C#
public static void Main()
{
    Point p;
    p.x = p.y = 1;
    Object o = p;        // p를 박싱하여 o에 객체 참조를 대입한다

    p = (Point) o;       // o를 언박싱하고 박싱된 인스턴스 내의 모든 필드를 스택 변수상으로 복사해 넣음
    p.x = 2;             // 스택 변수상의 x 필드값을 2로 변경함
    o = p;               // p를 박싱해서 새로운 객체를 만들고 그 객체의 참조를 o에 대입함
}
```

[박싱과 언박싱 예시]
```C#
public static void Main()
{
    Int32 v = 5;        // 박싱되지 않은 값 타입의 변수를 생성함
    Object o = v;       // o는 박싱된 Int32 객체에 대한 참조를 가리키고 여기에는 숫자 5가 들어감

    v = 123;            // 박싱되지 않은 변수 쪽의 값을 123으로 변경함

    Console.WriteLine(v+", "+ (Int32) o);   //"123, 5"가 나타남
    // WriteLine 메서드는 String 객체를 호출 시 필요로 함, 그러나... 아직 만들어진 게 없다
    // 객체들을 조합해서 호출에 필요한 String 객체를 만들어야 하는 상황...
    // String 인스턴스 만들기 위해 C# 컴파일러는 Concat 정적 메서드를 호출하는 코드를 만든다..
    // public static String Concat(Object arg0, Object arg1, Object arg2);
    // 언박싱 객체 + 참조 타입 객체 + 언박싱된 참조 객체
    // 박싱해야 함 + 변경할 필요 없음 + 박싱해야 함

}
```
- 어차피 Concat 메소드에서 박싱해줄 건데 o를 박싱할 게 뭐 있나?
- 마지막 명령문은 이렇게 변경하는 게 좋음
- `Console.WriteLine(v+", "+o);`
- 그런데 이렇게 작성하는 게 더 좋다
- `Console.WriteLine(v.ToString()+", "+o);`
- 박싱되지 않은 인스턴스 v에 대해 직접 호출되고 String 객체가 그 결과로 반환됨
- String 객체는 이미 참조 타입이므로 특별한 박싱 절차 없이 전달됨

- [박싱과 언박싱의 또 다른 예제]
```C#
public static void Main()
{
    Int32 v = 5;            // 박싱되지 않은 값 타입 객체를 만들고 5를 지정함
    Object o = v;           // v를 박싱하여 만들어진 객체의 참조를 o에 지정함

    v = 123;                // 박싱되지 않은 변수 쪽의 값을 123으로 변경함
    Console.WriteLine(v);   // "123"이 표시됨

    v = (Int32) o;          // o를 언박싱하여 v에 복사함
    Console.WriteLine(o);   //"5"가 표시됨
}
```
- 여기서는 박싱이 한 번만 일어났음
- 왜?
  - `public static void WriteLine(Int32 Value);` 를 사용하였기 때문에 굳이 박싱할 필요가 없었음

- 만든 코드에서 중복되는 하나의 값을 한 번만 박싱하여 여러 번 반복저긑로 재사용하도록 신경써서 만들어주면 코드가 좀 더 작은 크기를 유지하면서도 더 빠르게 실행 가능함

- 값 타입의 매개변수들에 대해서 상당히 많은 오버로드 메서드들이 존재함
- 대다수의 이런 메서드들은 일반적으로 통용되는 타입들에 대한 박싱을 최소화하기 위한 목적으로 배치되었음

- 고유한 값 타입을 만든다면 FCL 클래스들이 이 새로운 값 타입을 받아들이도록 처리할 메소드가 없다!!!
- 그래서 호출 과정에서 Object 타입으로 박싱하여 전달을 하게 됨
- 클래스를 작성한다면 클래스를 값 타입만 받을 수 있도록 제한하는 제네릭 클래스로 설계 가능
- 제네릭을 통해 어떤 종류의 값 타입이든 박싱 없이 처리할 수 있도록 메서드 정의가 가능하다.

- **개발자가 만든 코드에서 중복되는 하나의 값을 한 번만 박싱하여 여러 번 재사용하도록 만들어주면 코드가 좀더 작은 크기로 유지되며 더 빠르게 실행 가능해짐**

- 박싱되지 않은 값 타입들은 동기화 블록 인덱스가 없음 -> 다중 스레드 환경에서 인스턴스에 대한 접근 제어를 위해 System.Threading.Monitor 타입이나 C#의 lock 구문의 설정대상으로 이들을 지정할 수 없음
- **박싱/언박싱 방식은 시간이 아주 오래 걸리는 방식이므로 가능하면 사용하지 말고 제네릭을 사용해야 한다!!!!!⭐⭐⭐**
