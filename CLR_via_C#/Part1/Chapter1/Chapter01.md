# Chapter01. CLR의 실행모델
- 이 장의 목표:
    - .NET Framework는 어떻게 설계되었는가
    - .NET Framework가 포함하는 기술들
    - .NET Framework 용어들
    - 작성한 코드를 하나 이상의 클래스나 구조체 등의 타입을 포함하는 응용프로그램이나 재배포가 가능한 구성요소로 만드는 과정
    - 만든 응용프로그램이 어떻게 실행되는지 

## 소스코드를 관리 모듈로 컴파일하기
- 어떤 종류의 응용프로그램이나 구성요소를 만들 것인지 구상해야 함

- 어떤 프로그래밍 언어를 사용하여 프로그램을 만들 것인지 결정할 차례

- 각각의 언어들은 서로 다른 가능성과 장점을 가지고 있으므로 선택하기 쉽지 않음

- 예시: 비관리(Unmanaged) C/C++의 경우 상당히 낮은 수준(row-level)까지 시스템 제어 가능
  
    - 메모리를 어떤 방식으로 사용하고 관리할 것이지를 세밀하게 관리 가능, 필요에 따라 쓰레드 만들 수 있음, 이 외에도 여러 가지가 있음
    
- 예시: Visual Basic 6.0의 경우, 사용자가 UI를 쉽고 빠르게 만들 수 있도록 도움을 주고 COM(Component Object Model) 객체와 데이터베이스에 대한 제어를 간단하게 처리가능하게 함

- 공용 언어 런타임(Common Language Runtime, CLR)은 서로 다른 프로그래밍 언어들 사이에서 공동으로 사용 가능한 실행환경(Runtime)임
    - CLR의 핵심 기능들: 메모리 관리, 어셈블리 로딩, 보안, 예외 처리, 스레드 동기화 등
    - 이 기능들은 CLR을 지원하는 어떤 프로그래밍 언어라도 제약없이 자유롭게 사용 가능함
    - 실행 시점에서 발생한 오류를 보고하기 위해 예외를 사용하면 CLR을 지원하는 프로그래밍 언어라면 예외처리를 통해 오류가 발생했다는 사실을 알 수 있음
    - 공용 언어 런타임이 개발자에게 스레드 프로그래밍 기능을 제공하므로 공용 언어 런타임을 지원하는 어떤 프로그래밍 언어에서든지 스레드를 만들 수 있음
    - 그러나 실행 시점에 CLR은 개발자가 소스코드를 작성할 떄 어떤 프로그래밍 언어를 사용하였는지 알 수 있는 방법은 없음
    - 가장 잘 표현 가능한 프로그래밍 언어를 택하여 사용하기만 하면 됨
    - 컴파일러가 CLR 환경에서 코드가 작동가능하도록 컴파일할 수 있기만 하면 코드를 어떤 프로그래밍 언어에서라도 개발 가능함
    
- 근데 선택한 프로그래밍 언어를 다른 프로그램이 언어와 함께 쓸 수 있다는 것이 왜 좋을까?

- 컴파일러: 프로그래밍 언어의 문법에 따라 코드의 옳고 그름을 판단해주는 도구
    - 소스 코드 검사, 확인, 의도를 표현하는 코드 만들 것
    - 서로 다른 프로그래밍 언어를 통해 다채로운 문법을 사용하여 개발하는 것이 의외로 개발자에게 큰 이점을 주기도 함

- ![](cap1.PNG)

- 소스 코드 파일은 다음과 같은 과정을 거쳐 컴파일이 됨

- CLR을 지원하는 프로그래밍 언어라면 원하는 대로 소스코드 작성이 가능함

- 해당 언어를 지원하는 컴파일러를 사용하여 문법을 점검하고 소스 코드를 분석하게 됨

- 어떤 컴파일러를 사용하든 최종적으로 **관리 모듈**을 결과물로 얻게 됨

- 관리 모듈을 32비트 Windows용 표준 이식 가능 파일 또는 64 비트 Windows용 표준 PE 파일로 실행하기 위해서는 CLR이 필요함

- 관리 어셈블리는 Windows 환경에서 항상 데이터 실행 방지(Data Execution Prevention, DEP)와 임의 기준 주소(Address Space Layout Randomization, ASLR) 기술의 이점 누릴 수 있음

- 이 두 기술을 통해 시스템 전반에 대한 보안 강화 가능함

- [관리 모듈 내의 각 영역]

    - | 영역                 | 설명                                                         |
        | -------------------- | ------------------------------------------------------------ |
        | PE32 또는 PE32+ 헤더 | 표준 Windows PE 파일 헤더이며 공용 객체 파일 형식 헤더와 유사함<br> 이 부분이 PE32타입을 사용하고 있다면 이 파일은 32비트 또는 64 비트 버전의 Windows에서 모두 실행 가능<br>이 부분이 PE32+ 형식을 사용한다면 이 파일을 실행하기 위해 64 비트 버전의 Windows가 필요함<br>이 헤더는 응용프로그램의 타입 구분 가능, GUI, CUI, DLL의 여부를 구분하고 언제 파일이 작성되었는지 시간 정보도 포함하고 있음<br>IL 코드만을 포함하는 모듈의 경우, PE32 및 PE32+ 헤더의 정보들은 무시됨. 네이티브 CPU 코드를 포함하는 모듈의 경우 네이티브 CPU 코드에 관한 정보가 헤더에 포함됨 |
        | CLR 헤더             | 이 모듈이 관리 모듈로 취급되기 위해서 필요한 정보(CLR과 유틸리티에 의해 해석된)들이 포함됨 이 헤더 안에는 필요로 하는 CLR의 버전과 몇 가지 플래그, 관리 모듈의 진입점 메서드(Main 메서드)의 MethodDef 메타데이터 토큰, 모듈 내의 메타데이터, 리소스, 강력한 이름, 그 외 기타 플래그와 정보들이 모듈 내의 어느 위치에 존재하는지, 각 블록 크기에 대한 정보가 포함됨 |
        | 메타데이터           | 관리 모듈에는 메타 데이터 테이블이 들어있음<br>테이블은 크게 두 종류가 있음<br>- 소스 코드 안에 들어있는 타입들과 멤버들의 선언을 서술하는 테이블<br>- 소스코드가 참조하는 타입들과 멤버들에 대해 서술하는 테이블 |
        | IL 코드              | 소스코드를 컴파일하여 만든 코드, 실행 시에 CLR은 IL 코드를 다시 네이티브 CPU 명령어로 컴파일하게 됨 |

    

## 관리 모듈들을 하나의 어셈블리로 통합하기

## 공용 언어 런타임 로딩

## 어셈블리 코드 실행하기

## 네이티브 코드 생성 도구: NGEN.EXE

## 프레임워크 클래스 라이브러리

## 공용 타입 시스템

## 공용 언어 사양

## 비관리 코드와의 상호 운용성

