# Chapter02. 빌드, 패키징, 배포, 응용프로그램과 타입의 관리🍀

- 응용 프로그램과 그 안에 들어있는 타입들을 개발, 패키지로 만들고, 배포하는 단계에 대해 알아볼 것
- 응용 프로그램 내에서만 이용하는 어셈블리를 어떻게 만드는지 설명할 것임
- 관리자가 응용프로그램과 그 타입을 실행하는 것에 대해 어떻게 영향을 줄 수 있는지에 대해 이야기할 것임

## .NET Framework 배포 목표
- Windows는 불안정하고 복잡한 운영체제라는 인상을 가지고 있었음
- Windows OS에 대한 나쁜 인상의 첫 번재 이유: MS 또는 다른 모든 SW 제조사들이 만드는 프로그램들은 동적 링크 라이브러리(DLL)을 사용함
    - 사용자들은 어떤 제조사가 개발한 프로그램 내의 코드를 업데이트하고 새로운 파일을 배포할 때마다 문제를 겪게 됨
    - 배포된 새로운 파일들이 이전 버전의 파일과 호환성을 가지지 않는 경우가 있음
    - 새로운 응용프로그램 설치 시, 기존에 설치된 응용 프로그램들에 문제가 발생함
        - 이런 상황 = **DLL 지옥(DLL Hell)**

- Windows OS에 대한 나쁜 인상의 두 번재 이유: Windows 설치가 복잡하다고 여겨짐
    - 설치된 응용프로그램은 단순히 하나의 분리 가능한 항목이 아님
    - 설치되는 응용프로그램은 관련된 파일들과 만들어지는 레지스트리에 대한 정보도 함께 가져가야 함 -> 백업 위해서는어려운 작업을 거쳐야 함
    - 프로그램을 다른 컴퓨터로 가져가는 것도 어려움
    - 반드시 다른 PC에서도 같은 설치 프로그램 실행해서 모든 파일과 레지스트리 설정이 정확히 들어가도록 해줘야 함

- Windows OS에 대한 나쁜 인상의 세 번재 이유: 보안에 관련된 부분
    - 응용프로그램들이 설치되면 여러 다른 제조사들이 만든 파일이나 정보들이 함께 유입됨(얘가 무슨 짓을 할 지 몰라...)
    - 사용자들을 안심시키기 위해, 시스템에 보안에 대한 체계가 잡혀있어야 함
    - 컴퓨터의 다양한 자원에 접근 가능한 수많은 소프트웨어들ㅇ 대한 정책을 명시적으로 켜거나 끌 수 있도록 해야 함
    
## 모듈 안에 타입 만들기
```C#
public sealed class Program{
    public static void main()
    {
        System.Console.WriteLine("Hi");
    }
}
```
- 이 응용프로그램은 Program이라고 불리는 타입 하나를 정의하고 있음
- Main 안에는 System.Console이라는 타입에 대한 참조가 있음
- 이 타입은 MS 에 의해 구현되었고 중간 언어 코드가 이 타입을 구현하기 위해 MSCORLIB.DLL 파일 안에 쓰임

- 이 파일을 다음과 같은 명령문을 통해 컴파일함
`csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs`
- /out:Program.exe라는 명령문을 통해 C# 컴파일러에 PROGRAM.EE라는 실행 파일을 생성할 것을 요청함
- /t:exe 스위치를 통해 Win32 콘소 ㄹ응용프로그램의 형태로 만들 것을 요청 중
- /r:mscorlib.dll 스위치를 지정해서 컴파일러에 외부 타입들을 MSCORLIB.DLL이라는 파일 안에서 찾아보도록 지시함

- MSCORLIB.DLL파일은 핵심적인 기본 타입들을 포함하는 특별한 파일임
- 이런 타입들은 자주 쓰이므로 C# 컴파일러는 자동으로 MSCORLIB.DLL 어셈블리를 찾아봄
- /r 스위치를 무시하고 다음과 같이 써도 같은 의미임

`csc.exe /out:Program.exe /t:exe Program.cs`

- /out:Program.exe와 /t:exe 스위치도 기본값이므로 다음과 같이 줄여써도 같은 의미임

`csc.exe Program.cs`

- C# 컴파일러가 MSCORLIB.DLL 어셈블리를 참조하지 않게 ㅎ고 싶다면 /nostdlib 스위치 사용

## 메타데이터에 대해 잠시 살펴보기
- 메타데이터 블록은 켳 개의 테이블로 구성된 이진 데이터(Binary Data)임.
- 테이블은 세 가지 카테고리로 구분됨: 정의 테이블, 참조 테이블, 매니페스트 테이블

- PROGRAM.EXE 안에는 Program이라는 이름을 가지는 TypeDef 항목이 들어있음
- 이 타입은 어셈블리 안이든 밖이든 모두 접근을 허용하는 Public 한정자를 가지고 있음
- 추가 상속이 불가능한 sealed 타입
- 다른 어셈블리로부터 온 타입인 System.Object 타입으로부터 상속된 클래스 타입임
- Program 타입은 Main 메서드와 생성자 메서드인 .ctor 메서드를 정의하고 있다는 것 알 수 있음

- ILDASM.EXE 도구를 톻해 세부적인 정보를 얻을 수 있음 
- CLR 그 자체와 세부적인 기능들에 대해서도 이해 가능

## 여러 모듈을 하나의 어셈블리로 통합하기
- 어셈블리: 타입에 대한 정의가 담겨있는 파일 + 리소스 파일들
- 어셈블리는 매니페스트를 포함함
- 보안을 준수하는 기본 단위
- 매니페스트: 어셈블리의 일부로 포함되는 여러 다양한 파일들의 이름을 저장하는 메타데이터 테이블들의 또 다른 집합
    - 어셈블리의 버전, 문화권, 게시자, 외부에서 사용할 수 있도록 공개된 타입들, 어셈블리를 이루는 파일들에 대해 설명함

- CLR은 매니페스트 메타데이터 테이블 먼저 읽어들임
- 어셈블리 내부에 존재하는 다른 파일들 사용하기 위해 매니페스트를 사용하여 이름 확인
- **어셈블리의 주요한 특징**
    - 어셈블리 안에는 재사용 가능한 타입들을 정의하고 있음
    - 어셈블리에는 버전 번호가 기록되어 있음
    - 어셈블리는 어셈블리에 관련된 보안 정보들을 가지고 있을 수 있음
- 다중 파일 어셈블리(Multifile Assembly)를 사용하려는 이유
    - 배포하려는 타입들을 몇 개의 파일로 쪼개 분할 배포 가능, 앞에서 언급한 것처럼 인터넷상에서 다운로드할 경우 필요한 파일만을 다운로드해서 효율성 개선 가능
    - 리소스나 데이터 파일들을 어셈블리에 포함시킬 수 있음
    - 하나의 어셈블리를 만들면서 여러 다른 프로그래밍 언어로 만든 타입을 하나로 통합 가능함(단, 이 언어들이 모두 CLR을 사용해야 함)
- 어셈블리를 만들기 위해서는 PE 파일들 중 하나를 선택해서 매니페스트를 대표하도록 만들어야 함
- 또는 여러 개의 분리된 PE 파일을 만들고 매니페스트만 포함하도록 만들 수 있음

- 매니페스트를 포함한 파일은 어셈블리를 구성하는 파일들이 어떤 것인지 메타 데이터 정보 포함함
- 그러나 이에 해당되는 개별 파일들은 별도로 자신이 어셈블리의 일부라는 것을 설명하는 메타데이터를 가지고 있지 않음

- **Visual Studio는 다중 파일 어셈블리를 만드는 기능을 지원하지 않음**
- 그러므로 이하 생략...
### Visual Studio에서 어셈블리를 프로젝트에 추가하기
- 솔루션 탐색기 창에서 프로젝트 항목을 마우스 우클릭 => 참조 추가 메뉴를 클릭해야 함

## 어셈블리 버전 리소스 정보
- 어셈블리를 만들 떄는 반드시 버전 리소스 필드를 어셈블리 수준에서 적용하는 사용자 지정 특성(Custom Attributes)을 통해 설정해야 함
- C# 컴파일러 이용 시 명령 줄 스위치 대신 사용자 정의 특성이 지정된 필드로부터 관련된 정보를 읽어 설정하도록 하는 것이 보편적임

### 버전 번호
- 버전 번호에는 일정한 타입이 있음
- 네 개의 점으로 구분되는 문자열임

|      | 주 번호 | 부 번호 | 빌드 번호 | 리비전 번호 |
| ---- | ------- | ------- | --------- | ----------- |
| 예:  | 2       | 5       | 719       | 2           |
- 이 버전번호는 이렇게 씀
    - 2.5.719.2
- 처음 두 개의 번호는 외부에 공개되는 버전임
- 사용자들에게 어셈블리의 버전은 2.5로 기억됨
- 만약 어셈블리를 하루에 한 번씩 만든다면 빌드번호를 하나씩 증가시키면서 배포해야 함
- 마지막 번호: 리비전 번호
    - 이 어셈블리의 문제점을 수정하기 위하거나 다른 이유로 작은 붑누들을 수시로 수정하고 배포한다면 이 리비전 번호를 증가시키며 배포해야 함
    - MS에서는 이 버전 번호 체계를 사용, 이 방식 사용하여 버전 관리를 하면 편리함
- 어셈블리에는 세 가지 버전 번호 설정이 존재함
    - AssemblyFileVersion:
        - Win32 버전 리소스 안에 저장됨
        - 단순히 정보 표기를 위한 목적으로만 사용됨
        - 외부에 공개하기 위한 목적으로 주 번호, 부 번호 부분을 설정하는 것으로 충분함!
        - 빌드 시, 빌드번호, 리비전 번호가 자동으로 증가
    - AssemblyInformationVersion:
        - Win32 버전 리소스에 저장되는 정보
        - 정보 표시 및 참조용
        - CLR에서는 이 버전 번호 항목 전혀 고려 안 함
        - 이 버전 번호는 어셈블리 안에 들어있는 제품의 버전 번호를 식별하기 위한 목적으로 사용됨
    - AssemblyVersion:
        - 지정되는 버전 번호가 AssemblyDef 매니페스트 메타데이터 테이블이 기록되는 버전 번호
        - CLR은 이 버전 번호를 강력한 이름의 어셈블리를 바인딩하기 위해서 사용함
        - 이 버전 번호는 중요한 항목, 모든 어셈블리들을 개별적으로 식별하기 위한 기준이 됨
        - 어셈블리에 대한 개발을 시작하는 경우, 주 번호, 부 번호, 빌드 번호, 리비전 번호를 즉시 설정 -> 다음 배포 시점 이전까지 설정한 버전 번호를 고정한 채 작업을 진행해야 함
        - 다른 어셈블리를 참조하는 경우 참조한 어셈블리 버전이 AssemblyRef 테이블의 항목으로 이동

## 문화권
- 어셈블리는 자신을 식별하기 위한 문화권 정보를 가지고 있음
- RFC 1766 표준 사양에 따르는 문자열로 문화권 정보 식별 가능, 타입은 주 태그, 부 태그로 구성됨
- 보통 어셈블리를 만들 떄는 문화권 정보 직접 설정 안 함
- 특정 문화권에 종속되지 않는 코드 -> 중립 문화권으로 문화권 정보가 지정됨

- 특정 리소스에만 집중하는 하나 이상의 분리된 어셈블리들을 만들 수 있음 -> 각 어셈블리에는 코드가 전혀 포함되지 않음
- **위성 어셈블리**: 이런 형태로 만들어진 어셈블리에 문화권 정보만 설정되어 있는 형태
- 해당되는 문화권 정보 요청 -> 이에 해당되는 위성 어셈블리를 찾아 로드하고 설정을 반영하게 됨
- 지원하려는 문화권당 하나씩 위성 어셈블리를 만들어서 배포해야 함
- 위성 어셈블리를 참조하는 어셈블리는 만들지 말아야 함
- 어떤 어셈블리의 AssemblyRef 항목들은 모두 언어 중립ㅇ로 만들어진 어셈블리들만을 다루어야 함
- 만약 위성 어셈블리상에 내장된 타입이나 멤버를 접근해야 한다면 리플렉션을 이용해야 함

## 단순한 관리와 설정
- 의도하는 디렉터리 구조
```C#
AppDir 디렉터리 (응용프로그램의 어셈블리가 들어있는 디렉터리)
   Program.exe
   Program.exe.config(자세히 살펴볼 설정파일)

    AuxFiles 하위 디렉터리(MultiFileLibrary.DLL이 들어있는 디렉터리
    )
        MultiFileLibrary.dll
        FUT.netmodule
        FUT.netmodule
```
- .NET Framework 설치 시, MACHINE.CONFIG 라는 파일 만들게 됨
- 컴퓨터에 설치된 CLR의 버전마다 하나씩 MACHINE.CONFIG 파일이 만들어짐
