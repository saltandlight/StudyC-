# Chapter03. 공유 어셈블리와 강력한 이름의 어셈블리🐻

## 1. 두 가지 어셈블리, 두 가지 배포 방법
- CLR은 약한 이름의 어셈블리, 강력한 이름의 어셈블리를 지원함
- 두 어셈블리는 구조적으로 동일함
- 차이점: 
    - 강력한 이름의 어셈블리는 게시자의 공개키, 개인 키 한 쌍을 이용 -> 어셈블리 게시자 식별 가능하도록 서명함
    - 이 키쌍을 통해 어셈블리가 고유하게 식별되고 안저하게 유지되고 버전관리를 할 수 있음, 어셈블리가 컴퓨터 어디든 자유롭게 배포될 수 있도록 해줌
    - 어셈블리를 고유하게 식별할 수 있게 해주는 기능: CLR이 안전하다고 알려진 일부 정책들을 응용프로그램이 강력한 이름의 어셈블리에 바인딩 시 강제로 적용될 수 있게 해줌
- 어셈블리는 두 가지 형태로 배포될 수 있음
    - 개별적으로 배포되는 어셈블리: 응용프로그램의 기본 디렉터리나 그 아래의 디렉터리에 배포되는 것    
    - 전역으로 배포되는 어셈블리: 잘 알려진 위치에 배포됨 -> CLR이 어셈블리를 쉽게 찾을 수 있게 함
    
      | 어셈블리 종류        | 개별적으로 배포 가능 여부 | 전역으로 배포 가능 여부 |
      | -------------------- | ------------------------- | ----------------------- |
      | 약한 이름의 어셈블리 | Y                         | N                       |
      | 강한 이름의 어셈블리 | Y                         | Y                       |
    
## 2. 어셈블리를 강력한 이름으로 서명하기
- 여러 응용프로그램에서 하나의 어셈블리를 이용하는 경우, 어셈블리는 잘 알려진 디렉터리에 반드시 설치되어야 함
- CLR은 이런 어셈블리를 실행 중에 찾을 경우 이 디렉터리에서 찾을 수 있어야 함

- 문제가 있는데...
- 같은 파일 이름을 가진 어셈블리를 서로 다른 곳에 만들어 배포해야 할 수 있음

- 잘 알려진 디렉터리에 복사된 경우, 나중 복사된 어셈블리가 기존 어셈블리를 덮어씀 -> 이전 버전의 어셈블리 참조하던 모든 응용 프로그램들이 사용하던 함수 못 찾게 됨
- -> DLL 지옥의 원형

- 파일 이름을 이용 => 어셈블리를 구분하는 것은 불충분
- 고유하게 식별 가능한 새로운 매커니즘이 필요했음 -> 이 매커니즘 = 강력한 이름의 어셈블리
- 확장명 없는 파일 이름, 버전 번호, 문화권 정보, 공개 키 값 -> 어셈블리를 고유하게 식별

- 강력한 이름의 어셈블리 만들기 위한 첫 작업: .NET Framework SDK와 Visual Studio와 함께 제공되는 강력한 이름 SN.EXE
    - 지정하는 명령 줄 스위치 선택에 따라 종류 다양 -> 여러 기능 이용 가능
    - SN.EXE 유틸리티의 모든 명령 줄 스위치들은 대소문자 구분에 민감함
    - 공개 키/비밀 키 쌍을 생성하려면 다음과 같이 SN.EXE 유틸리티를 실행해야 함
    - `SN -k MyCompany.snk`

- 공개 키 숫자들의 값은 매우 큼
- 그래서 불편... -> 개발자들&사용자들의 편의를 위해 공개 키 토큰을 만듬
- 공개키 토큰: 64비트 해시 값

- 파일 서명의 의미: 
    - 강력한 이름의 어셈블리 생성 시, 어셈블리의 FileDef 매니페스트 메타테이블에 어슴블리를 구성하는 모든 파일들의 내역이 포함됨
    - 각 파일의 이름이 매니페스트에 추가됨, 파일의 내용이 해시 갑승로 계산 -> FileDef 테이블에 파일 이름마다 해시 값이 저장됨
    - 해시 값 계산 알고리즘의 선택: AL.EXE 유틸리티의  /algid 스위치 or 어셈블리 수준에서 System.Reflection.AssemblyAlgorithimIDAttribute 사용자 정의 특성을 어셈블리의 소스 코드 파일상에 넣어 지정 가능(기본 설정: SHA-1 알고리즘)

    - 매니페스트 포함한 PE 파일 만들어지면 PE 파일 내용 중 Authenticode 서명, 어셈블리의 강력한 이름 데이터, PE 헤더 체크섬을 제외한 모든 내용들이 해시 값으로 계산
    - 게시자의 비밀 키로 해시값이 서명됨 -> RSA 디지털 서명으로 해시에 포함되지 않은 PE 파일상의 예약된 공간에 저장됨
    - PE 파일의 CLR 헤더는 디지털 서명이 파일의 어느 위치에 기록되어 있는지를 가리키도록 수정됨

- 전체 공개키는 파일이 변조되지 않았는지 확인하는 과정에서 필요함
- 결론: 공개 키가 있으면 강력한 이름의 어셈블리, 아니라면 약한 이름의 어셈블리

## 전역 어셈블리 캐시
- 많은 응용 프로그램에 의해 어떤 어셈블리가 사용된다면, 이 어셈블리는 반드시 잘 알려진 디렉터리에 들어가야 함
- 이 잘 알려진 위치 = 전역 어셈블리 캐시(Global Assembly Cache, GAC)
- 보통 이 디렉터리가 GAC의 위치임
`%SYSTEMROOT%\Microsoft.NET\Assembly`

- GAC 디렉터리 밑에는 수많은 하위 디렉터리 있음, 하위 디렉터리들의 이름 짓기 위한 알고리즘도 있음
- 이 폴더 밑으로 파일 임의로 복사하여 집어넣는 것은 하면 안 됨
- 대신 지정된 도구 사용 -> GAC 에 새로운 어셈블리 추가 가능(이 도구들이 모든 걸 알고 있음)
- GAC 안에 약한 이름의 어셈블리 절대 추가 불가능

## 강력한 이름의 어셈블리를 참조하는 어셈블리 만들기

## 강력한 이름의 어셈블리로 코드 위조 방지하기

## 서명 연기

## 강력한 이름의 어셈블리를 개별적으로 배포하기

## 실행 중에 타입에 대한 참조를 어떻게 찾아내는가?

## 고급 관리 기능 제어와 설정