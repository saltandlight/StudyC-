# Chapter05. 기본, 참조, 값 타입🦁
## 프로그래밍 언어의 기본 타입
- 일부 데이터 타입들은 일반적이고 당연함 -> 많은 컴파일러들이 코드를 작성하는 동안 단순화된 문법의 형태로 이를 사용가능하도록 지원함
```C#
  System.Int32 a = new System.Int32;
```
- 그러나 정수형 변수를 선언, 초기화 위해 이처럼 하는 것은 번거로움...
- 다행히 C# 포함한 많은 컴파일러들은 단순한 문법 사용해서 쉽게 이 작업을 끝날 수 있게 함
```C#
  int a= 0;
```
- 처음의 문장과 의미가 동일한 IL 코드 만들어줌
- **기본 타입:** 컴파일러가 직접 지원하는 데이터 타입들
    - 프레임워크 클래스 라이브러리 상에 정의된 타입들과 직접 연결됨
    - 예: int 타입은 System.Int32 타입과 바로 연결됨
```C#
 int          a = 0;                 //가장 쓰기 쉬운 문법
 System.Int32 a = 0;                 //비교적 쉬움
 int          a = new int();         //불편함
 System.Int32 a = new System.Int32;  // 명시적이지만 너무 돌아가는 문법
```

| 기본타입 | FCL 타입       | CLS 호환 | 설명                                                         |
| -------- | -------------- | -------- | ------------------------------------------------------------ |
| sbyte    | System.SByte   | 아니오   | 부호 있는 8비트 정수값                                       |
| byte     | System.Byte    | 예       | 부호 없는 8비트 정수값                                       |
| short    | System.Int16   | 예       | 부호 있는 16비트 정수값                                      |
| ushort   | System.UInt16  | 아니오   | 부호 없는 16비트 정수값                                      |
| int      | System.Int32   | 예       | 부호 있는 32비트 정수값                                      |
| uint     | System.UInt32  | 아니오   | 부호 없는 32비트 정수값                                      |
| long     | System.Int64   | 예       | 부호 있는 64비트 정수값                                      |
| ulong    | System.UInt64  | 아니오   | 부호 없는 64비트 정수값                                      |
| char     | System.Char    | 예       | 16비트 유니코드 문자(char 타입은 비관리 C++에서 사용하던 8비트 값 포함하지 않음) |
| float    | System.Singloe | 예       | IEEE 32비트 부동 소숫값                                      |
| double   | System.Double  | 예       | IEEE 64비트 부동 소숫값                                      |
| bool     | System.Boolean | 예       | 참/거짓 논리 값                                              |
| decimal  | System.Decimal | 예       | 128비트 고해상도 부동 소수값이며 금융 관련 연산 위해 정의된 타입, 반올림 관련 오류 묵과되지 않음. 128비트 중 1비트는 부호 표기, 96비트는 값 자체를 표현, 8비트는 10의 지수 승을 표현, 앞의 96비트의 값을 나누기 위해 사용, 나머지 비트는 여유 공간으로 남김. 지수는 0~28 사이의값 |
| string   | System.String  | 예       | 문자의 배열                                                  |
| object   | System.Object  | 예       | 모든 타입들의 기본 타입                                      |
| dynamic  | System.Object  | 예       | 공용 언어 런타임 관점에서는 dynamic 키워드 자체는 object 타입과 동일하게 취급됨. 그러나 C# 컴파일러에서 dynamic 타입은 동적 코드를 처리하기 위한 단순화된 문법의 일부로 취급됨. |
- C# 컴파일러는 소스코드에 다음과 같은 using을 이용한 별칭 정의를 자동으로 삽입함
```C#
  using sbyte = System.SByte;
  using byte = System.Byte;
  using short = System.Int16;
  using ushort = System.UInt16;
  using int = System.Int32;
  using uint = System.UInt32;
```
- 컴파일러는 다음의 예시에서 설명하는 타입들에 대해 암묵적이든 명시적이든 형 변환이 가능하도록 해줌
```C#
  Int32  i = 5;         // Int32에서 Int32로 암묵적 타입 변환 
  Int64  l = i;         // Int32에서 Int64로 암묵적 타입 변환
  Single s = i;         // Int32에서 Single로 암묵적 타입 변환
  Byte   b = (Byte) i;  // Int32에서 Byte로 명시적 타입 변환
  Int16  v = (Int16) s; // Int32에서 Int16로 명시적 타입 변환
```
- C#은 암묵적 타입 변환을 "안전하다"고 판단하는 타입 변환 연산에 대해서만 허용
  - Int32에서 Int64로의 변환과 같이 타입 변환과정에서 데이터 손실이 없다고 판단할 때만 적용됨
  - 그러나 잠재적으로 데이터 손실 가능성이 우려되는 타입 변환 연산에 대해서는 명시적인 타입 변환 허용

- 컴파일러의 종류에 따라서 이런 타입 변환 코드가 다르게 구현될 수 있음
- Single 타입의 6.8을 Int32 타입으로 변환할 때, 어떤 컴파일러는 Int32 타입으로 변환하면서 숫자 값 6을, 또 다른 컴파일러는 반올림을 적용하여 숫자 값 7을 넣어줄 수 있음
- C#의 경우에는 반올림이 아닌 버림을 적용 -> 숫자 값 6을 넣어주게 됨
- 기본 타입은 변수가 아닌 리터럴 상수로 기재 가능
  - 리터럴 상수는 타입에 대한 인스턴스 그 자체로 취급 가능, 멤버 호출 가능
- 리터럴 상수로 구성되는 표현식이 있다면 컴파일러가 해당되는 표현식을 컴파일 타임에서 평가해서 응용프로그램의 성능을 향상시키도록 할 수 있음
```C#
  Boolean found = false;    //found 변수의 값을 false로 설정함
  Int32 x = 100 + 20 +3;    //x 변수의 값을 123으로 설정함
  String s = "a "+"bc";     //s 변수에 들어갈 문자열로 "a bc"를 설정함
```
- 컴파일러는 연산자가 하나 이상 사용되었을 때 어떤 것의 우선순위를 높게 잡아서 처리해야 하는지에 대한 사항을 자동으로 해석, 처리해줌
```C#
  Int32 x = 100;                    //대입 연산자
  Int32 y = x+23;                   // 덧셈 연산자 수행 후 대입 연산자 수행
  Boolean lessThanFifty = (y < 50); // 보다 작음 비교 후 대입 연산자 수행
```

### 기본 타입 연산의 오버플로우 여부 검사
- 개발자들은 수학적 연산에서 오버플로우 발생할 가능성에 대해 주의 기울임
```C#
 Byte b = 100;    
 b = (Byte) (b+200);  // b에는 44(또는 0x2C) 값이 들어감
```
## 참조 타입과 값 타입

## 박싱된 값 타입과 박싱되지 않은 값 타입

## 객체 해시 코드

## dynamic 기본 타입
