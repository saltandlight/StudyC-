# Chapter04. 타입의 기초💃
## 모든 타입은 System.Object를 상속한다
- 모든 타입들은 System.Object 타입으로부터 파생됨
- 다음 두 클래스에 대한 선언은 완전 same
```C#
//암시적으로 System.Object 타입으로부터 파생됨
class Employee {
    //...
}
```

```C#
//명시적으로 System.Object 타입으로부터 파생됨
class Employee : System.Object{
    //...
}
```
- 모든 타입들이 System.Object 타입으로부터 파생됨 -> 최소한의 공통 기능을 모든 타입들이 동일하게 가짐

- [System.Object 타입의 Public 인스턴스 메서드]

- | Public 메서드 | 설명                                                         |
  | ------------- | ------------------------------------------------------------ |
  | Equals        | 비교 대상으로 지정한 객체와 동일한 값을 가지는 경우 true를 반환. 5장에 더 자세히... |
  | GetHashCode   | 객체의 값으로부터 해시코드를 만들어 반환. Dictionary와 같이 해시 테이블 컬렉션에서 객체 사용하려면 이 메서드를 반.드.시 재정의해야 함. 이 메서드로 만들어지는 해시 코드는 객체 식별할 수 있도록 충분한 유일성 만족해야 함. 이 메서드는 인터페이스에 반드시 정의되어 있음 |
  | ToString      | 이 메서드의 기본 구현은 현재 타입의 전체 이름을 문자열로 반환하는 것. this.GetType().FullName과 같은 기능을 함. 이 메서드는 객체의 현재 상태를 설명하기 위한 용도로 재정의되곤 함. 디버깅을 목적으로 이 메서드를 재정의하는 것도 일반적임. 객체의 필드 값을 보기 위해 이 메서드를 재정의하고 호출 가능함. 적절한 지역 설정을 반영하는 문자열을 반환하도록 만드는 것이 바람직함 |
  | GetType       | GetType 메서드를 호출하기 위해 사용된 객체의 타입을 설명하는 Type 타입으로부터 파생된 객체의 인스턴스를 반환함. GetType 메서드는 비가상 메서드로 정의됨. 그래서 파생 클래스가 이 메서드를 재정의할 수 없도록 보호, 이로서 타입에 대한 정보 속이거나 잘못 전달해서 타입 안정성을 위반하지 않도록 예방함 |

- [System.Object 타입의 Protected 인스턴스 메서드]

- | Protected 메서드 | 설명                                                         |
  | ---------------- | ------------------------------------------------------------ |
  | MemberwiseClone  | 이 메서드는 비가상 메서드로 현재 인스턴스와 동일한 타입의 새로운 인스턴스 생성함. 그 후 현재 만들어진 객체의 모든 필드를 새 객체로 복사해서 새 객체의 참조를 반환하는 기능을 구현함 |
  | Finalize         | 이 가상 메서드는 현재 객체가 더 이상 사용되지 않는다는 것을 가비지 컬렉터가 파악했을 때, 이 객체에 대한 메모리 공간에 대한 회수 요청이 들어왔을 때 호출됨. 별도로 정리작업을 수행할 필요가 있는 타입에서는 반드시 이 메서드를 재정의해야 함. |

- CLR은 모든 객체들을 반드시 new 연산자에 의해 만들도록 하고 있음
- 다음의 코드는 Employee 객체를 어떻게 만드는지 간단히 보여줌
`Employee e = new Employee("ConstructorParam1");`
- new 연산자가 하는 일
    - 1. 할당하려는 타입과 별도의 인스턴스가 없는 System.Object 타입을 포함한 그 위의 모든 기본 타입들에서 정의된 모든 인스턴스 필드들을 메모리에 할당하기 위한 바이트 수를 계산함. 힙 상의 모든 객체에는 별도의 추가적인 멤버로, 타입 객체 포인터(Type Object Pointer)와 동기화 블록 인덱스가 추가되며 CLR에 의해 객체를 관리하기 위해 사용됨. 이 추가 멤버들을 위한 바이트는 객체의 실제 크기에 포함됨
    - 2. 지정된 타입의 할당에 필요한 바이트의 수만큼 관리되는 힙으로부터 객체를 위해 메모리를 할당, 처음 할당 시 모든 바이트를 0으로 초기화함
    - 3. 객체의 타입 객체 포인터와 동기화 블록 인덱스 멤버를 초기화함
    - 4. 클래스 타입의 인스턴스 생성자+인수 -> new 연산자에서 서술한 대로 전달됨 각각의 호출되는 생성자는 타입에 의해 정의된 인스턴스 필드들을 초기화해야 함. 호출되는 생성자는 상속 관계에 따라 거슬러 올라가 최종적으로 System.Object의 생성자를 부름. 이 생성자는 하는 일 없이 반환됨

- new 연산자에 의해 모든 작업이 실행되면 새로 만들어진 객체의 참조(포인터)를 반환.
- 그런데...new 연산자에 대응되는 delete 연산자는 존재하지 않음, 명시적으로 객체의메모리를 할당 해제할 방법 없음
    - 가비지 컬렉션 기반의 메모리 관리 사용함으로 사용되지 않는 객체를 자동 추적, 메모리 해지 -> 메모리 공간 회수하는 일 자동으로 처리함

## 타입 간 캐스팅하기
- CLR의 중요한 기능들 중 하나는 타입 안정성~!
- 실행 시점에서 CLR은 객체의 정확한 타입이 무엇인지 항상 파악하고 있음

- 개발자들은 특정 객체를 다른 타입으로 캐스팅하는 코드를 자주 작성함
- CLR은 객체의 현재 타입에 근접한 타입 or 기본 타입으로 캐스팅을 지원함


### C#의 is와 as 연산자로 캐스팅하기

## 네임스페이스와 어셈블리

## 실행 시점과의 연관성
